
let programStart=Date.now();
let time=0;
window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame||function(funct){
if((Date.now()-programStart)-time>=60){
time=Date.now()-programStart;
funct(time);
}else{
setTimeout(window.requestAnimationFrame,59-((Date.now()-programStart)-lastFrame),funct);
}
};
var KEYS={
pressed:new Set(),
events:{
held:[],
pressed:[],
released:[]
},
bindKeyHold:(keys,cb)=>{
if(Array.isArray(keys))
for (let key of keys)
KEYS.events.held.push({
key:key,
callback:cb
})
else
KEYS.events.held.push({
key:keys,
callback:cb
})
},
bindKeyPressed:(keys,cb)=>{
if(Array.isArray(keys))
for (let key of keys)
KEYS.events.pressed.push({
key:key,
callback:cb
})
else
KEYS.events.pressed.push({
key:keys,
callback:cb
})
},
bindKeyReleased:(keys,cb)=>{
if(Array.isArray(keys))
for (let key of keys)
KEYS.events.released.push({
key:key,
callback:cb
})
else
KEYS.events.released.push({
key:keys,
callback:cb
})
},
combination:(args)=>{return { type:"combination",keys:args }}
}
const allChars='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_';
var Random={
random:Math.random,
range:(min,max)=>(Math.random()*(max-min)+min),
choice:(choices)=>{
if(choices instanceof Object) choices=Object.values(choices);
return choices[Math.floor(Math.random()*choices.length)];
},
choices:(choices,k)=>{
let ret=[];
while (ret.length<=k){
ret.push(this.choice(choices));
}
return ret;
},
string:function(leng,chars){
leng=leng||12;
chars=chars||allChars;
let string='';
for (let i=0; i<leng; i++){
string+=chars[Math.floor(Math.random()*(chars.length-1))];
}
return string;
},
permutation:function(leng,amt,start=1){
let rets=[];
for (let i=0; i<amt; i++){
rets.push(this.choice(Math.range(start,leng)));
}
return rets;
},
bits:function(k){
let bits='';
while (bits.length<=k){
bits+=this.choice(['0','1'])
}
return bits;
}
}
Math.range=(start,end)=>{
return Array(end-start+1).fill().map((_,idx)=>start+idx)
}
document.addEventListener('keydown',(e)=>{
KEYS.pressed.add(e.key);
for (let ev of KEYS.events.pressed){
if(ev.key===e.key){
ev.callback()
}
}
});
document.addEventListener('keyup',(e)=>{
KEYS.pressed.delete(e.key);
for (let ev of KEYS.events.released){
if(ev.key===e.key){
ev.callback()
}
}
});
let FPSel=document.getElementById('FPS');
/*
Sources for Ideas:
https:https:*/
const SHAPES={
rect:function(ctx,x,y,w,h){
ctx.fillRect(x,y,w,h);
},
circle:function(ctx,x,y,w,h){
ctx.beginPath();
ctx.arc(x+w/2,y+h/2,(w+h)/4,2*Math.PI,false);
ctx.fill();
}
}
class Camera {
constructor(width,height){
this.width=width;
this.height=height;
this.offsetX=0;
this.offsetY=0;
this.zoom=1;
this.rotation=0;
this.centerOfRot=(0,0);
}
rotateRad(rad){
this.rotation+=rad;
}
rotateDeg(deg){
this.rotation+=deg*Math.PI/180;
}
setRotationCenter(x,y){
this.centerOfRot=(x,y);
}
}
function rectCollide(t1,t2){
return (t1.left<t2.right&&
t1.right>t2.left&&
t1.top<t2.bottom&&
t1.bottom>t2.top);
};
function lineLineCollide(x1,y1,x2,y2,x3,y3,x4,y4){
const uA=((x4-x3)*(y1-y3)-(y4-y3)*(x1-x3))/((y4-y3)*(x2-x1)-(x4-x3)*(y2-y1))
const uB=((x2-x1)*(y1-y3)-(y2-y1)*(x1-x3))/((y4-y3)*(x2-x1)-(x4-x3)*(y2-y1))
if(uA>=0&&uA<=1&&uB>=0&&uB<=1){
const intersectionX=x1+(uA*(x2-x1));
const intersectionY=y1+(uA*(y2-y1));
return {
collision:true,
x:intersectionX,
y:intersectionY
};
}
return {
collision:false
};
}
function rectLineCollide(rect,line){
const left=lineLineCollide(line.x1,line.y1,line.x2,line.y2,rect.x,rect.y,rect.x,rect.y+rect.height)
if(left.collision)
return {
collision:true,
x:left.x,
y:left.y
}
const right=lineLineCollide(line.x1,line.y1,line.x2,line.y2,rect.x+rect.width,rect.y,rect.x+rect.width,rect.y+rect.height)
if(right.collision)
return {
collision:true,
x:right.x,
y:right.y
}
const top=lineLineCollide(line.x1,line.y1,line.x2,line.y2,rect.x,rect.y,rect.x+rect.width,rect.y)
if(top.collision)
return {
collision:true,
x:top.x,
y:top.y
}
const bottom=lineLineCollide(line.x1,line.y1,line.x2,line.y2,rect.x,rect.y+rect.height,rect.x+rect.width,rect.y+rect.height)
if(bottom.collision)
return {
collision:true,
x:bottom.x,
y:bottom.y
}
return {
collision:false
};
}
class Game {
constructor(opts){
opts=opts||{};
this.camera=new Camera();
this.things=[];
this.texts=[];
this.FPS=0;
this.deltaTime=0;
this.timestamp=0;
this.viewmode=opts.viewmode||'2d';this.rendering=opts.rendering||'2d';this.background=opts.background||"white";
this.canvas=document.querySelector(opts.canvas||"canvas");
this.context=this.canvas.getContext(this.rendering);
this.canvas.width=opts.width||this.canvas.style.width||document.body.offsetWidth;
this.canvas.height=opts.height||this.canvas.style.height||document.body.offsetHeight;
this.width=this.canvas.width;
this.height=this.canvas.height;
this.left=-this.width/2;
this.right=this.width/2;
this.top=-this.height/2;
this.bottom=this.height/2;
this.friction=opts.friction||1;
this.hooks=[];
this.running=false;
const parent=this;
this.Container=class {
constructor({
x,
y,
width,
height,
overhead,
left,
right,
top,
bottom,
background,
...opts
}){
width=width||radius*2||null;
if(!width&&((left&&right)||(left&&x)||(right&&x))){
width=parent.numberDistance(right,left)||parent.numberDistance(x,left)*2||parent.numberDistance(right,x)*2;
}else if(!width) width=20;
height=height||radius*2||null;
if(!width&&((top&&bottom)||(top&&y)||(bottom&&y))){
height=parent.numberDistance(top,bottom)||parent.numberDistance(y,top)*2||parent.numberDistance(bottom,y)*2;
}else if(!height) height=20;
x=x||(left+width/2)||(right-width/2)||0;
y=y||(top+height/2)||(bottom-height/2)||0;
top=y-height/2;
left=x-width/2;
bottom=y+height/2;
right=x+width/2;
this._data={
width:width,
height:height,
x:x,
y:y,
top:top,
left:left,
bottom:bottom,
right:right,
}
}
get x(){
return this._data.x;
}
set x(val){
this._data.x=val;
this._data.left=val-this._data.width/2;
this._data.right=val+this._data.width/2;
}
get y(){
return this._data.y;
}
set y(val){
this._data.y=val;
this._data.top=val-this._data.height/2;
this._data.bottom=val+this._data.height/2;
}
get left(){
return this._data.left;
}
set left(val){
this._data.left=val;
this._data.x=val+this._data.width/2;
this._data.right=val+this._data.width;
}
get top(){
return this._data.top;
}
set top(val){
this._data.top=val;
this._data.y=val+this._data.height/2;
this._data.bottom=val+this._data.height;
}
get right(){
return this._data.right;
}
set right(val){
this._data.right=val;
this._data.x=val-this._data.width/2;
this._data.left=val-this._data.width;
}
get bottom(){
return this._data.bottom;
}
set bottom(val){
this._data.bottom=val;
this._data.y=val-this._data.height/2;
this._data.top=val-this._data.height;
}
get width(){
return this._data.width;
}
set width(val){
this._data.width=val;
this._data.left=this._data.x-val/2;
this._data.right=this._data.x+val/2;
}
get height(){
return this._data.height;
}
set height(val){
this._data.height=val;
this._data.top=this._data.y-val/2;
this._data.bottom=this._data.y+val/2;
}
draw(){
}
}
this.Text=class {
constructor({
text,
color,
background,
width,
x,
y,
size,
font,
align,
overhead,
...opts
}){
this.text=text;
this.overhead=overhead||false;
this.color=color||"black";
this.background=background;
this.width=width;
this.x=x||0;
this.y=y||0;
this.size=size||16;
this.font=font||"Arial";
this.align=align||"left";
parent.texts.push(this);
}

draw(){
parent.context.textAlign=this.align;
parent.context.font=`${this.size}px ${this.font}`;
if(this.background){
parent.context.fillStyle=this.background;
parent.context.fillRect(this.x,this.y,parent.context.measureText(this.text),this.size);
}
parent.context.fillStyle=this.color;
parent.context.fillText(this.text,this.x,this.y);
}
};
this.Thing=class {
constructor({
width,
height,
x,
y,
left,
right,
top,
bottom,
shape,
background,
radius,
collisions,
overhead,
...opts
}){
this.overhead=overhead||false;
this.name=opts.name||'unidentified';
if(typeof shape=='string')
shape=SHAPES[shape];
this.shape=shape||SHAPES.rect;

width=width||radius*2||null;
if(!width&&((left&&right)||(left&&x)||(right&&x))){
width=parent.numberDistance(right,left)||parent.numberDistance(x,left)*2||parent.numberDistance(right,x)*2;
}else if(!width) width=20;
height=height||radius*2||null;
if(!width&&((top&&bottom)||(top&&y)||(bottom&&y))){
height=parent.numberDistance(top,bottom)||parent.numberDistance(y,top)*2||parent.numberDistance(bottom,y)*2;
}else if(!height) height=20;
radius=radius||(width+height)/4||10;
x=x||(left+width/2)||(right-width/2)||0;
y=y||(top+height/2)||(bottom-height/2)||0;
top=y-height/2;
left=x-width/2;
bottom=y+height/2;
right=x+width/2;
this._data={
width:width,
height:height,
radius:radius,
x:x,
y:y,
top:top,
left:left,
bottom:bottom,
right:right,
}
this.id=Random.string(12)+this.name;
this.background=background||"green";
this.realX=0;
this.realY=0;
this.checkCollisions=collisions||true;
this.collisions={};
this.events={};
this.prevX=0;
this.prevY=0;
this.vel={
x:0,
y:0,
}
this._destination=null;
parent.things.push(this);
}
get x(){
return this._data.x;
}
set x(val){
this._data.x=val;
this._data.left=val-this._data.width/2;
this._data.right=val+this._data.width/2;
}
get y(){
return this._data.y;
}
set y(val){
this._data.y=val;
this._data.top=val-this._data.height/2;
this._data.bottom=val+this._data.height/2;
}
get left(){
return this._data.left;
}
set left(val){
this._data.left=val;
this._data.x=val+this._data.width/2;
this._data.right=val+this._data.width;
}
get top(){
return this._data.top;
}
set top(val){
this._data.top=val;
this._data.y=val+this._data.height/2;
this._data.bottom=val+this._data.height;
}
get right(){
return this._data.right;
}
set right(val){
this._data.right=val;
this._data.x=val-this._data.width/2;
this._data.left=val-this._data.width;
}
get bottom(){
return this._data.bottom;
}
set bottom(val){
this._data.bottom=val;
this._data.y=val-this._data.height/2;
this._data.top=val-this._data.height;
}
get width(){
return this._data.width;
}
set width(val){
this._data.width=val;
this._data.left=this._data.x-val/2;
this._data.right=this._data.x+val/2;
}
get height(){
return this._data.height;
}
set height(val){
this._data.height=val;
this._data.top=this._data.y-val/2;
this._data.bottom=this._data.y+val/2;
}
get radius(){
return this._data.radius;
}
set radius(val){
this._data.radius=val;
this._data.width=val*2;
this._data.height=val*2;
this._data.left=this._data.x-val;
this._data.right=this._data.x+val;
this._data.top=this._data.y-val;
this._data.bottom=this._data.y+val;
}


/*get id(){
delete this.id;
return 
}*/
delete(){
parent.things=parent.things.filter(x=>x!==this);
this.draw=()=>null;
delete this.x,this.y,this.width,this.height,this.radius,this.left,this.right,this.top,this.bottom,this._data,this.triggerEvent;
}

getCollider(){
/*let rectCollider={
left:this._data.left,
top:this._data.top,
right:this._data.right,
bottom:this._data.bottom,
width:this._data.width,
height:this._data.height,
x:this._data.x,
y:this._data.y,
prevX:this.prevX,
prevY:this.prevY
}

if(this.shape===SHAPES.circle){
rectCollider.width-=0;
rectCollider.height-=0;
}

return rectCollider;
return this;
}

collided(other,cb){
if(!Array.isArray(other)){
if(!this.collisions[other.id]) this.collisions[other.id]=[]
this.collisions[other.id].push(cb)
}else{
for (let oth of other){
if(!this.collisions[oth.id]) this.collisions[oth.id]=[]
this.collisions[oth.id].push(cb)
}
}
}

when(evt,cb){
if(!this.events[evt]) this.events[evt]=[]
this.events[evt].push(cb)
}

triggerEvent(name){
if(this.events[name])
for (let cb of this.events[name]) cb()
}

posUpdate(){
this.realX=this._data.left+(parent.width/2);
this.realY=this._data.top+(parent.height/2);
if(!this.overhead){
this.realX+=parent.camera.offsetX;
this.realY+=parent.camera.offsetY;
}
}

distanceTo(other){
return Math.sqrt((this.x-other.x)**2+(this.y-other.y)**2)
}

update(){

this.prevX=this.x;
this.prevY=this.y;
this.move(this.vel.x*parent.deltaTime,this.vel.y*parent.deltaTime)
/*
Problems with our Collision Detection:
1. Its very expensive to check every object against every other object even if they are a thousand pixels away. 
2. Fast objects are able to go through any other object without the collision being detected.

Potential Solutions:
1. A broad phase where we decide which ones to check by if their y positions overlap at all. Or some other type of broad phase.
2. Draw a line between the current position and projected position and check if that line intersects with the object. Or some other solution
*/
for (let other of parent.things.filter(x=>{
return x.id!==this.id&&x.checkCollisions
})){let rectCollider=other.getCollider();
let rectCollider2=this.getCollider();


let t1HalfW=this._data.width/2;
let t1HalfH=this._data.height/2;
let t2HalfW=other._data.width/2;
let t2HalfH=other._data.height/2;

if(
this.distanceTo(other)<rectCollider2._data.width+
rectCollider._data.width+
rectCollider2._data.height+
rectCollider._data.height&&
rectCollide(rectCollider,rectCollider2)
){
let diffX=this._data.x-other._data.x;
let diffY=this._data.y-other._data.y;

let minXDist=t1HalfW+t2HalfW;
let minYDist=t1HalfH+t2HalfH;

let depthX=diffX>0?minXDist-diffX:-minXDist-diffX;
let depthY=diffY>0?minYDist-diffY:-minYDist-diffY;

let axis,side;
if(depthX!=0&&depthY!=0){
if(Math.abs(depthX)<Math.abs(depthY)){
axis='x';
if(depthX>0){
side='left';
}else{
side='right';
}
}else{
axis='y';
if(depthY>0){
side='top';
}else{
side='bottom';
}
}
}
if(this.collisions[other.id])
/*let event={
axis:axis,
side:side,
self:this,
other:other,
timestamp:parent.timestamp
}*/
this.collisions[other.id].forEach(cb=>cb(axis,side,this,other));
}
}
}

draw(){
this.update();

this.triggerEvent("moved");
this.posUpdate();

parent.context.fillStyle=this.background;

this.shape(parent.context,this.realX,this.realY,this._data.width,this._data.height);
if(this._destination){
if((this._destination[0]=='*'||this._destination[0]==this._data.x)&&(this._destination[1]=='*'||this._destination[1]==this._data.y)){
this._destination=null;
return;
}
let d=this._destination;
if(d[0]!='*'&&this._data.x+this.vel.x/1000>=d[0]&&this.vel.x>0){
this.vel.x=0;
this.x=d[0];
}else if(d[0]!='*'&&this._data.x+this.vel.x/1000<=d[0]&&this.vel.x<0){
this.vel.x=0;
this.x=d[0];
}
if(d[1]!='*'&&this._data.y+this.vel.y/1000>=d[1]&&this.vel.y>0){
this.vel.y=0;
this.y=d[1];
}else if(d[1]!='*'&&this._data.y+this.vel.y/1000<=d[1]&&this.vel.y<0){
this.vel.y=0;
this.y=d[1];
}
}
}
teleport(x,y){
this._data.x=x;
this._data.left=x-this._data.width/2;
this._data.right=x+this._data.width/2;
this._data.y=y;
this._data.top=y-this._data.height/2;
this._data.bottom=y+this._data.height/2;
}
moveX(amt){
this._data.x+=amt;
this._data.left+=amt;
this._data.right+=amt;
}
moveY(amt){
this._data.y+=amt;
this._data.top+=amt;
this._data.bottom+=amt;
}
move(x,y){
this._data.x+=x;
this._data.left+=x;
this._data.right+=x;
this._data.y+=y;
this._data.top+=y;
this._data.bottom+=y;
}
to(x,y,speedX,speedY){
if(x=='*') speedX=0;
else if(speedX==0) x='*'
if(y=='*') speedY=0;
else if(speedY==0) y='*'

this._destination=[x,y];

if(x>this._data.x) this.vel.x=speedX;
else this.vel.x=-speedX;
if(y>this._data.y) this.vel.y=speedY;
else this.vel.y=-speedY;
}
}
}
hook(for_,hook){
if(!this.hooks[for_]) this.hooks[for_]=[];
this.hooks[for_].push(hook);
}
triggerHook(for_,...params){
if(this.hooks[for_])
for (let i=0; i<this.hooks[for_].length; i++)
this.hooks[for_][i](...params);
}
getCurrentState(){
}
saveState(id){
this._states[id]=this.getCurrentState();
}
restoreState(id){
}
pointDistance(x1,x2,y1,y2){
return Math.sqrt((x1-x2)**2+(y1-y2)**2);
}
numberDistance(a,b){
return a>b?a-b:b-a
};
start(){
if(this.running) return;
this.running=true;
let elapsed=0;
let lastFrame=0;
const self=this;
function gameLoop(t){
self.timestamp=t;
self.triggerHook("gameloop");
elapsed=t-lastFrame;
lastFrame=t;
self.deltaTime=elapsed/1000;
self.FPS=1000/elapsed;
self.context.fillStyle=self.background;
self.context.fillRect(0,0,self.canvas.width,self.canvas.height);
for (let ev of KEYS.events.held){
if(KEYS.pressed.has(ev.key)) ev.callback(elapsed)
}
for (let thing of self.things)
thing.draw(elapsed);
for (let text of self.texts)
text.draw();
if(self.running) window.requestAnimationFrame(gameLoop);
}
window.requestAnimationFrame(gameLoop);
}
stop(){
if(this.running) this.running=false;
}
}
